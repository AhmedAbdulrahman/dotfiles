"Use UTF-8 without BOM"
set encoding=UTF-8

" Change to English version"
let $LANG = 'en_US'
set langmenu=en_US

" Vundle Plugins {{"
  if filereadable(expand("$HOME/.vim_plugins"))
    source $HOME/.vim_plugins
  endif
" }}"

" Theme and Styling {{"
  syntax on

  " enable true colors support"
  set termguicolors

  "Theme"
  "set bg=dark"
  set background=dark
  colorscheme material-theme

  if exists('$TMUX')
    let &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
    let &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
  endif

  hi VertSplit         ctermbg=NONE guibg=NONE
  hi Normal            ctermbg=NONE guibg=NONE
  hi LineNr            ctermbg=NONE guibg=NONE
  hi htmlTag guifg='#00bdec' guibg='#200000' gui=bold
  hi CursorLineNr ctermfg=white

" }}"

" General Settings {{"

  "yep - the space bar is my leader keyset"
  let mapleader = "\<Space>"           
  set shell=zsh                         " Set bash as the prompt for Vim"
  set backupskip=/tmp/*,/private/tmp/*  " Don’t create backups when editing files in certain directories"
  set nowb
  set noswapfile

  set fillchars=vert:\ ,stl:\ ,stlnc:\ 
  set confirm

  " Disable error bells."
  set noerrorbells

  " Use visual bell instead of audible bell"
  set visualbell 

  " Only insert single space after a '.', '?' and '!' with a join command."
  set nojoinspaces 

  "set ttymouse=xterm2"
  set so=999

  "to limit ctrlp search"
  set wildignore+=*/tmp/*,/dist/*,/node_modules/*,*.so,*.swp,*.zip

  "Allow cursor keys in insert mode"
  set esckeys

  " speed up vim "
  set ttyfast
  set lazyredraw

  "Add the g flag to search/replace by default"
  set gdefault

  "Don’t add empty newlines at the end of files"
  set binary														

  set noeol

  let g:elite_mode=1	                                      " Enable Elite mode, No ARRRROWWS!!!!"
  
  " Enable highlighting of the current line"
  augroup highlight_follows_focus
    autocmd!
    autocmd WinEnter * set cursorline
    autocmd WinLeave * set nocursorline
  augroup END

  augroup highligh_follows_vim
    autocmd!
    autocmd FocusGained * set cursorline
    autocmd FocusLost * set nocursorline
  augroup END

  "Enable mouse in all modes"
  set mouse=a

  "Always show current position"
  set ruler

  "Don’t show the intro message when starting Vim"
  set shortmess=atI

  "Show the (partial) command as it’s being typed"
  set showcmd

  "Start scrolling three lines before the horizontal window border"
  set scrolloff=3

  " Start scrolling three columns before vertical border of window"
  set sidescrolloff=3 
  set scrolljump=5

  "Allow backspace in insert mode"
  set backspace=indent,eol,start

  "Enable per-directory .vimrc files and disable unsafe commands in them"
  set exrc

  set secure

  "Reload files that have been changed outside vim"
  set autoread 

  "Make Vim more useful"
  set nocompatible

  " Markers are used to specify folds. "
  set foldmethod=syntax                                     " fold based on indent"
  set foldnestmax=10                                        " deepest fold is 10 levels"
  set nofoldenable                                          " don't fold by default"
  set foldlevel=1

  " Allow folding single lines "
  set foldminlines=0 

  " Set max fold nesting level "
  set foldnestmax=3 

  " Format comments "
  set formatoptions+=c 

  " Format comments with gq "
  set formatoptions+=q 

  " Recognize numbered lists "
  set formatoptions+=n 

  " Use indent from 2nd line of a paragraph "
  set formatoptions+=2 

  " Don't break lines that are already long "
  set formatoptions+=l 

  " Break before 1-letter words "
  set formatoptions+=1 

  " By default add g flag to search/replace. Add g to toggle. "
  set gdefault 

  " When a buffer is brought to foreground, remember undo history and marks. "
  set hidden 

  " Remember copy history after quiting. "
  "set viminfo='20,\"500'"

  " Increase history from 20 default to 1000"
  set history=1000 

  "Set Interactive file tree view"
  set backspace=indent,eol,start

  " Character for CLI expansion (TAB-completion)."
  set wildignore+=*.jpg,*.jpeg,*.gif,*.png,*.gif,*.psd,*.o,*.obj,*.min.js,*.sql
  set wildignore+=*/bower_components/*,*/node_modules/*,node_modules/*
  set wildignore+=*/wp-/plugins/*,*/w3tc-config/*,*/cache/*
  set wildignore+=*/smarty/*,*/vendor/*,*/.git/*,*/.hg/*,*/.svn/*,*/.sass-cache/*,*/log/*,*/tmp/*,*/build/*,*/ckeditor/*,*/doc/*,*/source_maps/*,*/dist/*

  " Hitting TAB in command mode will show possible completions above command line"
  set wildmenu 

  " For YouCompleteMe messes"
  set shortmess+=c

  " Set relative line numbers"
  if exists("&relativenumber")
    set relativenumber
    au BufReadPost,BufNewFile * set relativenumber
  endif

  au BufRead,BufNewFile *.json set ft=json syntax=javascript

  if executable('jq')
    autocmd BufRead *.json :%!jq .
  endif

  "Persistent Undo"
  if has('persistent_undo')
    let target_path = expand('~/.vim/vim-persisted-undo/')

    if !isdirectory(target_path)
      call system('mkdir -p ' . target_path)
    endif

    let &undodir = target_path
    set undofile
  endif

  set clipboard=unnamedplus
  "use default clipboard on MAC"
  if has('mac')
      set clipboard=unnamed
  endif

  "LESS"
  au BufNewFile,BufRead *.less set filetype=css

  autocmd BufNewFile,BufRead *.md set filetype=markdown

  "Common Ruby files"
  au BufRead,BufNewFile Rakefile,Capfile,Gemfile,.autotest,.irbrc,*.treetop,*.tt set ft=ruby syntax=ruby

  "Common javascript files"
  au BufRead,BufNewFile *.jsx,*.ts set ft=javascript syntax=javascript

  "ZSH"
  au BufRead,BufNewFile .zsh_rc,.functions,.commonrc set ft=zsh

  "Speed up transition from modes"
  if ! has('gui_running')
    set t_Co=256
    set ttimeoutlen=10
    augroup FastEscape
      autocmd!
      au InsertEnter * set timeoutlen=0
      au InsertLeave * set timeoutlen=1000
    augroup END
  endif

  "Enable filetype plugins"
  filetype plugin indent on

  " Always show status line"
  set laststatus=2 

  let g:airline#extensions#tabline#enabled = 1

  "Enable line numbers"
  set number

  "Sets line spacing but only in gui"
  set linespace=12

  "Show the filename in the window titlebar"
  set title

  set titlestring=%F\ -\ vim

  " Show the current mode"
  set showmode

  " Show tab bar if there is more than one"
  set showtabline=1 

  " Don't show the intro message when starting vim"
  set shortmess=atI 

  set lcs=tab:·\ ,trail:·,eol:¬,nbsp:_ "Show “invisible” characters"
  set list

  " Add vertical spaces to keep right and left aligned "
  set diffopt=filler

  " Ignore whitespace changes (focus on code changes) "
  set diffopt+=iwhite

  " Change colour of tildes at the end of the buffer "
  highlight EndOfBuffer ctermfg=black

  " Border colour "
  hi! VertSplit ctermfg=2 ctermbg=NONE term=NONE

  "Strip trailing whitespace (,ss)"
  function! StripWhitespace()
    let save_cursor = getpos(".")
    let old_query = getreg('/')
    :%s/\s\+$//e
    call setpos('.', save_cursor)
    call setreg('/', old_query)
  endfunction

  "1.3 File behaviour "
  "-------------------"
  set linebreak
  set breakindent

  " Don't reset cursor to start of line when moving around."
  set nostartofline

  " Set Proper Tabs"
  set tabstop=4

  " Don't use actual tab character (ctrl-v)"
  set noexpandtab

  " Indenting is 4 spaces"
  set shiftwidth=4 
  "set expandtab"	                 "Don’t reset cursor to start of line when moving around."

  "At start of line, <Tab> inserts shiftwidth spaces, <Bs> deletes shiftwidth spaces"
  set smarttab

  " set nowrap Do not wrap lines"
  set wrap

  "Make tabs as wide as two spaces"
  set modeline

  " Respect modeline in files"
  set modelines=4

  " Show all changes"
  set report=0

  " 1.4 Search {{"
    " Ignore 'ignorecase' if search patter contains uppercase characters"
    set smartcase 

    " do not highlight searches, incsearch plugin does this"
    set hlsearch

    " Incremental highlight term as pattern is typed "
    set incsearch

    " Ignore case of searches "
    set ignorecase

    " Searches wrap around end of file"
    set wrapscan

    " match to be used with %"
    set matchpairs+=<:> 

    " Enable extended regexes "
    set magic

    " show matching braces "
    set showmatch

    " how many tenths of a second to blink "
    set mat=2

    " automatically set indent of new line "
    set autoindent 
    set smartindent

    "clearing highlighted search"
    nmap <silent> <leader>/ :nohlsearch<CR>

  " }}"

  " 1.5 Panes {{"
    " New window goes below"
    set splitbelow 

    " New windows goes right"
    set splitright

    "Allow splits to be reduced to a single line"
    set winminheight=0

    " No extra spaces between rows"
    set linespace=0
  " }}"

" }}"


" Mappings {{"
  "Mouse scrolling"
  map <ScrollWheelUp> <C-Y>
  map <ScrollWheelDown> <C-E>

  " Change Working Directory to that of the current file"
  cmap cwd lcd %:p:h
  cmap cd. lcd %:p:h

  " Status Line"
  set statusline=%F%m%r%h%w%=(%{&ff}/%Y)\ (line\ %l\/%L,\ col\ %c)\
  if exists("*fugitive#statusline")
    set statusline+=%{fugitive#statusline()}
  endif

  "# hi StatusLine ctermbg=0 ctermfg=7
  ""# hi StatusLineNC ctermbg=0 ctermfg=2
  ""let g:Powerline_symbols = 'fancy'"

  "autocomplete window colours"
  highlight Pmenu ctermfg=15 ctermbg=239
  highlight PmenuSel ctermfg=250 ctermbg=236

  "Speed up viewport scrolling"
  nnoremap <C-e> 3<C-e>
  nnoremap <C-y> 3<C-y>

  "Delete buffer without closing window"
  map <Leader>d :BD<cr>

  "Move faster up/down"
  nmap <C-j> 5j
  xmap <C-j> 5j
  nmap <C-k> 5k
  xmap <C-k> 5k

  "Move faster left/right"
  nmap <C-h> 5h
  xmap <C-h> 5h
  nmap <C-l> 5l
  xmap <C-l> 5l

  "Move lines"
  nnoremap <S-j> :m .+1<CR>==
  nnoremap <S-k> :m .-2<CR>==

  inoremap <S-j> <Esc>:m .+1<CR>==gi
  inoremap <S-k> <Esc>:m .-2<CR>==gi

  vnoremap <S-j> :m '<-2'<CR>gv=gv
  vnoremap <S-k> :m '>+1'<CR>gv=gv

  "copy line and leave a marker"
  nnoremap yy yymy

  "Highlighted yank"
  let g:highlightedyank_highlight_duration = 300

  "Disable arrow keys"
  inoremap <Up>    <NOP>
  nnoremap <Up>    <NOP>
  inoremap <Down>  <NOP>
  nnoremap <Down>  <NOP>

  "Split current window"
  nnoremap <C-w>- :split file<CR>
  nnoremap <C-w>\ :vsplit file<CR>
  nnoremap <leader>- :split file<CR>
  nnoremap <leader>\ :vsplit file<CR>

  "map <C-h> :call WinMove('h')<cr>"
  "map <C-j> :call WinMove('j')<cr>"
  "map <C-k> :call WinMove('k')<cr>"
  "map <C-l> :call WinMove('l')<cr>"

  "easy regex replace for current word"
  nnoremap <Leader>s :%s/\<<C-r><C-w>\>/
  xnoremap <leader>s :<c-u>%s/\%V

  "select but dont jump"
  nnoremap <Leader>8 *#
  nnoremap <Leader>3 #*

  "Indent/unident block"
  "nnoremap <leader>] >i[
  nnoremap <leader>[ <i[
  nnoremap <leader>} >i{
  nnoremap <leader>{ <i{
  "
  "Buffer navigation"
  map <Tab><Tab> <C-^>
  map <Leader>l :bnext<CR>
  map <Leader>h :bprev<CR>

  "when pairing some braces or quotes, put cursor between them"
  inoremap <>   <><Left>
  inoremap ()   ()<Left>
  inoremap {}   {}<Left>
  inoremap []   []<Left>
  inoremap ""   ""<Left>
  inoremap ''   ''<Left>
  inoremap ``   ``<Left>

  "Buffer resizing"
  nnoremap <Leader>H :vertical resize -4<cr>
  nnoremap <Leader>J :resize +5<cr>
  nnoremap <Leader>K :resize -5<cr>
  nnoremap <Leader>L :vertical resize +5<cr>

  "Fix page up and down"
  map <PageUp> <C-U>
  map <PageDown> <C-D>
  imap <PageUp> <C-O><C-U>
  imap <PageDown> <C-O><C-D>

  " Close Quickfix window"
  map <leader>qq :cclose<CR>

  "save using <C-s> in every mode when in operator-pending or insert, takes you to normal mode"
  nnoremap <C-s> :write<Cr>
  vnoremap <C-s> <C-c>:write<Cr>
  inoremap <C-s> <Esc>:write<Cr>
  onoremap <C-s> <Esc>:write<Cr>

  "Fast save/exiting"
  nnoremap <leader>q :q!<CR>
  nnoremap <leader>z ZZ
  nnoremap <leader>w :w<CR>

  "Close pane using <C-w>"
  noremap <silent> <C-w> :call <SID>__bclose()<Cr>

  "shortcuts for quickfix list"
  nnoremap <silent> <C-n> :call <SID>__qfnxt()<Cr>
  nnoremap <silent> <C-b> :call <SID>__qfprv()<Cr>

  "strip trailing whitespace"
  noremap <Leader>ss :call StripWhitespace()<CR>

  map q <Nop>
  map <F6> :setlocal spell!<CR>
  inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"          "<TAB>: completion."  

  "Pressing * or # on Visual mode, searches for the current selection "
  vnoremap <silent> * :call VisualSelection('f')<CR>
  vnoremap <silent> \# :call VisualSelection('b')<CR>
"}}"

" Plugins {{"

  let c='a'
  while c <= 'z'
    exec "set <A-".c.">=\e".c
    exec "imap \e".c." <A-".c.">"
    let c = nr2char(1+char2nr(c))
  endw

  set timeout ttimeoutlen=50
  
  " NerdTree configuration {{" 
    autocmd StdinReadPre * let s:std_in=1
    autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif

    "Tab managment - Useful mappings for managing tabs "
    map <leader>tn :tabnew<cr>
    map <leader>to :tabonly<cr>
    map <leader>tc :tabclose<cr>
    map <leader>tm :tabmove

    nnoremap <silent> <Leader>v :NERDTreeFind<CR>
    map <leader>t :NERDTreeToggle<CR>
    let g:NERDTreeShowHidden=1	                                      "Show hidden files in NERDTree"
    let g:NERDTreeMinimalUI=1	                                        "Disable display of '?' text and 'Bookmarks' label."
    let g:NERDTreeMouseMode=2	                                        "Single-click to toggle directory nodes, double-click to open non-directory nodes."
    let g:NERDTreeQuitOnOpen=0	                                      "Close NERDTree after a file is opened"
    let g:NERDTreeChDirMode=2
    let g:NERDTreeIgnore=['\.rbc$', '\~$', '\.pyc$', '\.db$', '\.sqlite$', '__pycache__']
    let g:NERDTreeSortOrder=['^__\.py$', '\/$', '*', '\.swp$', '\.bak$', '\~$']
    let g:NERDTreeShowBookmarks=1
    let g:nerdtree_tabs_focus_on_files=1
    let g:NERDTreeMapOpenInTabSilent = '<RightMouse>'
    let g:NERDTreeWinSize = 50
  " }}"

  " TagBar {{"
    map <C-m> :TagbarToggle<CR>
    let g:tagbar_autofocus=1
    let g:tagbar_compact = 1
    let g:tagbar_usearrows = 1
    let g:tagbar_autoshowtag = 1
  " }}"

  " JSDOC {{"
    let g:javascript_plugin_jsdoc = 1	                      " Enable JSDoc highlighting "
    let g:javascript_plugin_flow = 1	                      " Enable Flow syntax highlighting "
    " Allow JSX syntax in JS files "
  " }}"
  
  " Emmet {{"
    let g:jsx_ext_required = 0	                            " lets emmet use jsx shortcuts"
    "Set Emmet to apply jsx settings to javascript.jsx filetype"
    let g:user_emmet_settings = {
    \  'javascript.jsx' : {
    \      'extends' : 'jsx',
    \      'quote_char': "'",
    \  },
    \}
    autocmd FileType html,css,javascript,jsx EmmetInstall
    imap <expr> <tab> emmet#expandAbbrIntelligent("\<tab>")
  " }}"

  " Prettier {{"
    let g:prettier#autoformat = 0
    autocmd BufWritePre *.js,*.jsx,*.mjs,*.ts,*.tsx,*.css,*.less,*.scss,*.json,*.graphql,*.md,*.vue PrettierAsync
    nmap <Leader>p <Plug>(Prettier)
  " }}"

  " UiSnippets {{"
    let g:UltiSnipsExpandTrigger="<c-j>"
    let g:UltiSnipsJumpForwardTrigger="<c-b>"
    let g:UltiSnipsJumpBackwardTrigger="<c-z>"
    let g:UltiSnipsSnippetsDir="~/.vim/Ultisnips"
    let g:UltiSnipsSnippetDirectories=['Ultisnips']
  " }}"

  
  " Tagged Template {{"
    "NOTE: Tag on the left, filetype on the right "
    let g:taggedtemplate#tagSyntaxMap = {
      \ "html": "html",
      \ "md":   "markdown",
      \ "css":  "css" }
    autocmd FileType javascript,javascript.jsx,typescript : call taggedtemplate#applySyntaxMap()
  " }}"

  " ALE {{"
    let local_eslint = finddir(getcwd() . '/node_modules') . '/.bin/eslint'
    if matchstr(local_eslint, "^\/\\w") == ''
        let local_eslint = local_eslint
    endif

    let g:ale_javascript_eslint_executable = local_eslint

    "enable completion where available."
    let g:ale_completion_enabled = 1

    let g:ale_fixers = {
    \   'javascript': ['eslint'],
    \   'typescript': ['eslint'],
    \   'typescriptreact': ['eslint']
    \}

    let g:ale_linters = {
    \   'javascript': ['eslint'],
    \   'typescript': ['eslint'],
    \   'jsx': ['eslint'],
    \   'html': [],
    \}

    let g:ale_linter_aliases = {'jsx': 'css'}

    "use a slightly slimmer error pointer"
    let g:ale_sign_error = '✖'
    hi ALEErrorSign guifg=#DF8C8C
    let g:ale_sign_warning = '⚠'
    hi ALEWarningSign guifg=#F2C38F

    highlight ALEErrorSign ctermfg=18 ctermbg=73 cterm=bold
    highlight ALEWarningSign ctermfg=18 ctermbg=73 cterm=bold

    " Ale error shortcuts"
    nmap <silent> <Leader>k <Plug>(ale_previous_wrap)
    nmap <silent> <Leader>j <Plug>(ale_next_wrap)
    "nmap <Leader>d <Plug>(ale_fix)"
  " }}"

  let g:rainbow#max_level = 16
  let g:rainbow#pairs = [['(', ')'], ['[', ']'], ['{', '}']]

  let g:lightline = {
    \     'active': {
    \         'left': [['mode', 'paste' ], ['readonly', 'filename', 'modified']],
    \         'right': [['lineinfo'], ['percent'], ['gitbranch', 'fileformat', 'fileencoding']]
    \     },
    \     'component_function': {
    \         'gitbranch': 'gitbranch#name'
    \     }
    \ }


  " Fzf {{"
    let g:fzf_layout = { 'down': '75%' }
      let g:fzf_colors =
      \ { 'fg':      ['fg', 'Normal'],
        \ 'bg':      ['bg', 'Clear'],
        \ 'hl':      ['fg', 'String'],
        \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
        \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
        \ 'hl+':     ['fg', 'Statement'],
        \ 'info':    ['fg', 'PreProc'],
        \ 'prompt':  ['fg', 'Conditional'],
        \ 'pointer': ['fg', 'Exception'],
        \ 'marker':  ['fg', 'Keyword'],
        \ 'spinner': ['fg', 'Label'],
        \ 'header':  ['fg', 'Comment'] }

    command! -bang -nargs=? -complete=dir Files
    \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)

    nnoremap <silent> <leader><tab> :Files<CR>
    nnoremap <silent> <leader><leader> :Buffers<CR>
    nnoremap <silent> <leader>; :BLines<CR>
    nnoremap <silent> <leader>O :BTags<CR>
    nnoremap <silent> <leader>o :Tags<CR>
    nnoremap <silent> <leader>? :History<CR>

    nnoremap <silent> <leader>ft :Filetypes<CR>

    imap <c-x><c-p> <plug>(fzf-complete-path)
    imap <C-x><C-f> <plug>(fzf-complete-file-rg)
    imap <C-x><C-l> <plug>(fzf-complete-line)

    let g:fzf_layout = { 'down': '75%' }

    " The Silver Searcher"
    if executable('ag')
      " Use ag over grep"
      set grepprg=ag\ --nogroup\ --nocolor
    endif

    if executable('rg')
      set grepprg=rg\ --vimgrep\ --color=never\ --glob\ '"!*/plugins/*"'

      " Ripgrep and fzf settings"
        command! -bang -nargs=* Rg
          \ call fzf#vim#grep(
          \   'rg --column --line-number --no-heading --iglob "!**/dist/**" --iglob "!**/language/**" --iglob "!**/lang/**" -g "!*.sql" -g "!*.min.js" --color=always '.shellescape(<q-args>), 1,
          \   fzf#vim#with_preview(),
          \   <bang>0)
    endif

    command! -bang -nargs=* Find call fzf#vim#grep('rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --glob "!.git/*" --color "always" '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
    nnoremap <leader>/ :Rg<cr>
  " }}"

  " Airline {{"
    let g:airline_theme = 'powerlineish'
    let g:airline#extensions#syntastic#enabled = 1
    let g:airline#extensions#branch#enabled = 1
    let g:airline#extensions#tabline#enabled = 1
    let g:airline#extensions#tagbar#enabled = 1
    let g:airline_skip_empty_sections = 1
    let g:airline#extensions#virtualenv#enabled = 1

    if !exists('g:airline_symbols')
      let g:airline_symbols = {}
    endif

    if !exists('g:airline_powerline_fonts')
      let g:airline#extensions#tabline#left_sep = ' '
      let g:airline#extensions#tabline#left_alt_sep = '|'
      let g:airline_left_sep          = '▶'
      let g:airline_left_alt_sep      = '»'
      let g:airline_right_sep         = '◀'
      let g:airline_right_alt_sep     = '«'
      let g:airline#extensions#branch#prefix     = '⤴'
      let g:airline#extensions#readonly#symbol   = '⊘'
      let g:airline#extensions#linecolumn#prefix = '¶'
      let g:airline#extensions#paste#symbol      = 'ρ'
      let g:airline_symbols.linenr    = '␊'
      let g:airline_symbols.branch    = '⎇'
      let g:airline_symbols.paste     = 'ρ'
      let g:airline_symbols.paste     = 'Þ'
      let g:airline_symbols.paste     = '∥'
      let g:airline_symbols.whitespace = 'Ξ'
    else
      let g:airline#extensions#tabline#left_sep = ''
      let g:airline#extensions#tabline#left_alt_sep = ''

      "powerline symbols"
      let g:airline_left_sep = ''
      let g:airline_left_alt_sep = ''
      let g:airline_right_sep = ''
      let g:airline_right_alt_sep = ''
      let g:airline_symbols.branch = ''
      let g:airline_symbols.readonly = ''
      let g:airline_symbols.linenr = ''
    endif
  " }}"

  " Fugitive {{"
    nnoremap <silent> <leader>ga :Git add %:p<CR><CR>
    nnoremap <silent> <leader>gs :Gstatus<CR>
    nnoremap <silent> <leader>gc :Gcommit -a<cr>
    nnoremap <silent> <Leader>gb :Gblame<CR>
    nnoremap <silent> <leader>gd :Gdiff<CR>
    nnoremap <silent> <leader>gl :GV<CR>
  " }}"

" }}"

" Custom Functions {{"
  
  " since I know it from Chrome / VSCode (cmd+w) and do not use the <C-w> mappings anyway"
  function! s:__bclose()
    if (len(getbufinfo({'buflisted': 1})) > 1)
      bdelete
    endif
  endfunction

  " I like things that wrap back to start after end, quickfix stops at last error but if I specify cn again, I want to definitely go to the next error (I can see line numbers in sidebar to track where I am anyway)"
  fun! s:__qfnxt()
    try
      cnext
    catch
      crewind
    endtry
  endfun

  fun! s:__qfprv()
    try
      cprev
    catch
      clast
    endtry
  endfun

  " Visual mode related"
  " Visual mode pressing * or # searches for the current selection"

  function! VisualSelection(direction) range
      let l:saved_reg = @
      execute "normal! vgvy"

      let l:pattern = escape(@, '\\/.*$^~[]')
      let l:pattern = substitute(l:pattern, "\n$", "", "")

      if a:direction == 'b'
          execute "normal ?" . l:pattern . "^M"
      elseif a:direction == 'gv'
          call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
      elseif a:direction == 'replace'
          call CmdLine("%s" . '/'. l:pattern . '/')
      elseif a:direction == 'f'
          execute "normal /" . l:pattern . "^M"
      endif

      let @/ = l:pattern
      let @ = l:saved_reg
  endfunction

  " Returns true if paste mode is enabled"
  function! HasPaste()
      if &paste
          return 'PASTE MODE  '
      en
      return ''
  endfunction

  "Rename file name"
  function! RenameFile()
      let old_name = expand('%')
      let new_name = input('New file name: ', expand('%'), 'file')
      if new_name != '' && new_name != old_name
          exec ':saveas ' . new_name
          exec ':silent !rm ' . old_name
          redraw!
      endif
  endfunction

  "Rename"
  map <leader>n :call RenameFile()<cr>

  " Window movement shortcuts move to the window in the direction shown, or create a new window"
  function! WinMove(key)
      let t:curwin = winnr()
      exec "wincmd ".a:key
      if (t:curwin == winnr())
          if (match(a:key,'[jk]'))
              wincmd v
          else
              wincmd s
          endif
          exec "wincmd ".a:key
      endif
  endfunction

  "Codi Config"
  let g:codi#width         = 50.0
  let s:codi_filetype_tabs = {}

  function! s:FullscreenScratch()
    " store filetype and buffer of current buffer for later reference"
    let current_buf_ft  = &ft
    let current_buf_num = bufnr('%')

    " check if a scratch buffer for this filetype already exists"
    let saved_scratch = get(s:codi_filetype_tabs, current_buf_ft, -1)

    " if a tabpage exists for current_buf_ft, go to it instead of creating a new scratch buffer"
    if saved_scratch != -1
      if index(map(gettabinfo(), 'v:val.tabnr'), saved_scratch) == -1
        unlet s:codi_filetype_tabs[current_buf_ft]
      else
        exe 'tabn' saved_scratch
        return
      endif
    endif

    "create a new empty tab, set scratch options and give it a name"
    tabe
    setlocal buftype=nofile noswapfile modifiable buflisted bufhidden=hide
    exe ':file scratch::' . current_buf_ft

    " set filetype to that of original source file e.g. ruby / python / w/e Codi supports"
    let &filetype = current_buf_ft

    " store the tabpagenr per filetype so we can return to it later when re-opening from the same filetype"
    let s:codi_filetype_tabs[&filetype] = tabpagenr()

    " create a buffer local mapping"
    nmap <silent><buffer> <Leader>bl :tabprevious<Cr>

    " everything is setup, filetype is set let Codi do the rest :)"
    Codi
  endfunction
  "Codi: create a mapping to call the fullscreen scratch wrapper"
  nmap <silent> <Leader>c :call <SID>FullscreenScratch()<Cr>

  "Show changes since last save"
  function! s:DiffSaved()
    let filetype=&ft
    diffthis
    vnew | r # | normal! 1Gdd
    diffthis
    exe "setl bt=nofile bh=wipe nobl noswf ro ft=" . filetype
  endfunction
  command! DS call s:DiffSaved()
" }}"

" Setting Font"
"set guifont=Droid\ Sans\ Mono\ for\ Powerline\ Nerd\ Font\ Complete\ 14"
set guifont=Source\ Code\ Pro\ for\ Powerline\ 10